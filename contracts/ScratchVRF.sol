// SPDX-License-Identifier: MIT
pragma solidity ^0.8.8;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "./ScratchNFT.sol";

// TODO after deployment:
// fund contract with Verse  
// register contract with Chainlink VRF service 
// upload prize mapping
contract VerseVRF is Ownable, VRFConsumerBaseV2 {
    using SafeERC20 for IERC20;

    VRFCoordinatorV2Interface private immutable vrfCoordinator;
    ScratchNFT nftContract;

    uint64 constant SUBSCRIPTION_ID = 776;
    uint16 constant CONFIRMATIONS_NEEDED = 3;
    uint32 constant CALLBACK_MAX_GAS = 2000000;
    bytes32 constant GAS_KEYHASH = 0xcc294a196eeeb44da2888d17c0625cc88d70d9760a69d58d853ba6581a9ab0cd; // 500 gwei
    address constant TOKEN_ADDRESS = 0xd4061c196b26C72EcA1951829D90eB7Ad02693F0; // ERC20- Polygon

    uint256[] public ticketsRemaining;
    uint256 public ticketCost;

    bool prizePreset = false;

    struct Drawing {
        uint32 result;
        uint maximumNumber;
        uint256 drawId;
        address payable ticketReceiver;
    }

    uint256[] private _randomNumbers;
    
    mapping(uint256 => uint256) public prizeMapping;
    mapping(uint256 => uint256) public drawIdToRequestId;
    mapping(uint256 => Drawing) public requestIdToDrawing;
    mapping (uint256 => bool) public claimedPrize;

    uint public drawId = 0;
 
    /// @notice initialize contract and set the VRF Coordinator address
    /// @param _vrfCoordinatorV2Address The address of the Chainlink VRF Coordinator v2.
    /// @param _maxTickets max number of tickets that can be sold
    /// @param _ticketCost cost of ticket in currency (cost in ethers, not wei)
    constructor(address _vrfCoordinatorV2Address, uint _maxTickets, uint _ticketCost) 
    VRFConsumerBaseV2(_vrfCoordinatorV2Address)
    {
        nftContract = new ScratchNFT("SV1", "V1");
        vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinatorV2Address);
        ticketCost = _ticketCost;
        
        for (uint256 i = 1; i <= _maxTickets;) {
            ticketsRemaining.push(i);
            unchecked { 
                ++i; 
            }
        }
    }

    /// @notice callback function for chainlink's VRF
    /// @dev amount of gas this function is allowed to spent is set on vrfCoordinator.requestRandomWords 
    /// @param _requestId id of the vrf request
    /// @param _randomWords array with random numbers generated by VRF
   function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords)
        internal
        override
    {
        Drawing storage currentDraw = requestIdToDrawing[_requestId];

        if(ticketsRemaining.length > 0) {
            uint256 maximumNumber = ticketsRemaining.length;

            currentDraw.result = uint32((_randomWords[0] % maximumNumber));
            // _mint(currentDraw.ticketReceiver, ticketsRemaining[currentDraw.result]);
            nftContract.mint(ticketsRemaining[currentDraw.result],currentDraw.ticketReceiver);
            removeElementAtIndex(currentDraw.result);

            emit requestFulfilled(currentDraw.drawId, _requestId, maximumNumber, currentDraw.result);
        } else {
            // edge case if someone requests to buy last ticket
            // while it was already sold
            // we need to refund the user as its sold out
            address payable recipient = currentDraw.ticketReceiver;
            IERC20(TOKEN_ADDRESS).safeTransferFrom(address(this), recipient, ticketCost * 1 ether);
        }
    }
 
    /// @notice request to draw n (numbersDrawn) random numbers between 0 and maximumnumber.
    function buyScratchTicket() public {
        require(prizePreset == true, "sale has not started yet");
        require(ticketsRemaining.length > 0, "No tickets remaining");

        IERC20(TOKEN_ADDRESS).safeTransferFrom( msg.sender, address(this), ticketCost * 1 ether);

        uint256 requestId = vrfCoordinator.requestRandomWords(
            GAS_KEYHASH, // gas keyhash (sepoila 30 gwei)
            SUBSCRIPTION_ID, // subscription id
            CONFIRMATIONS_NEEDED, // conf needed
            CALLBACK_MAX_GAS, // callback gas 
            1 // amount of numbers
        );
        ++drawId;

        Drawing memory newDrawing = Drawing({
            result: 0,
            maximumNumber: ticketsRemaining.length,
            drawId: drawId,
            ticketReceiver: payable(msg.sender)
        });

        requestIdToDrawing[requestId] = newDrawing;
        drawIdToRequestId[drawId] = requestId;
        emit DrawRequest(drawId, requestId, msg.sender);
    }

    function removeElementAtIndex(uint256 index) private {
        require(index < ticketsRemaining.length, "Index out of bounds");
        
        for (uint256 i = index; i < ticketsRemaining.length - 1;) {
            ticketsRemaining[i] = ticketsRemaining[i + 1];
            unchecked {
                ++i;
            }
        }
        ticketsRemaining.pop(); 
    }

    function claimPrize(uint tokenId) public {
        require(nftContract.ownerOf(tokenId) == address(msg.sender), "only NFT owner can claim prize");
        require(claimedPrize[tokenId] != true, "prize has been claimed already");
        
        uint256 prizeWei = prizeMapping[tokenId] * 1 ether;
        uint256 balance = IERC20(TOKEN_ADDRESS).balanceOf(address(this));
        require(balance >= prizeWei, "contract does not have enough funds to payout");
        
        nftContract.setClaimed(tokenId);
        claimedPrize[tokenId] = true;
        IERC20(TOKEN_ADDRESS).safeTransfer(msg.sender, prizeWei);
    }

    // method has to be called by owner before the draw starts to load in prize
    // options
    function setPrizes(uint256[] memory keys, uint256[] memory values) public onlyOwner {
        require(prizePreset == false, "prizes have already been set");
        require(keys.length == values.length, "Array lengths do not match");
        
        for (uint256 i; i < keys.length;) {
            prizeMapping[keys[i]] = values[i];
            unchecked {
                ++i;
            }
        }
        prizePreset = true;
    }

    // withdraw tokens from smart contract
    function withdraw() public onlyOwner {
        uint256 balance = IERC20(TOKEN_ADDRESS).balanceOf(address(this));
        require(balance > 0, "No tokens to withdraw");
        IERC20(TOKEN_ADDRESS).safeTransfer(owner(), balance);
    }


    event DrawRequest(
        uint256 indexed drawId,
        uint256 indexed requestId,
        address indexed ticketReceiver
    );

    event requestFulfilled(
        uint256 indexed drawId,
        uint256 indexed requestId,
        uint256 maxNumber,
        uint32 result
    );

}
